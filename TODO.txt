Perhaps we should make it easier to obtain a reference to the dataItem by allowing the argument to be any element inside the editor.
The API would call $(elem).closest('[data-uid]').attr('data-uid') to obtain the UID.

Should we compile the templates? It might be faster than resolving functions on every call to supplant.
Or we could simply create a dictionary for each template, calling getObjectAtPath on each one.
Create a Template class. Instantiate it with the original string template.
The constructor would compile the template by creating a dictionary of functions for each token.
The Template class would have standard functions for returning data properties, either escaped or raw.
It would first call getObjectAtPath and assign what it finds to the dictionary.
If nothing is found, it would assume it's a property name.

Perform a survey of everything the templating engine needs to do its job.
Convert all templates and helpers into standard functions.
Each function should have a mechanism for declaring what arguments it needs.
Create a templating engine module that is supplied with some grid-specific resources:
- the datamap
- columns
- data
- pageModel
- node
- the current data item
- config object
- the templating engine itself
- any of the other templates and/or helpers
- etc
The engine uses dependency injection to supply each function with arguments.
Instead of calling the template functions directly, set some properties on the templating engine and call a render function, 
passing in the template name.

Invert the templates so none of them call other templates or helpers.
Instead, inject whatever they need. Example, tableBody needs thead, tableRows, and tfoot.
Pass these into the template via a model or inject them. 
Problem: thead and tfoot are dependent on whether or not there are fixed headers and/or footers.
Can we conditionally inject these easily? 
Create separate templates for fixed/unfixed header and fixed/unfixed footer.
The only difference between them is that they would either render or not depending on how the grid is configured.
Modify the injector so it constructs a model object from the dependent resources and passes it in.
That way we can use a static template and can call supplant with it.

Change the commands so it can be either a comma-separated string or an array of objects.

Currently it's not possible to pass a url to an event delegate call:
gridponent('#theGrid').rowSelected('http://server/app/controller/action/{{id}}');
Should this be supported?

Return 'this' from as many API functions as possible.

Make sure boolean checkboxes can create an explicit false when creating new records.
This might happen when the model for new records contains no default for a boolean property.

Test to make sure the script initialization method can contain objects and still survive the resolution process.

gp.getType should always return a string type.

Can we isolate the controllers commandHandler from the editors? Don't like relying on differences in command value.

Eliminate setting config.dataItem.

What happens if a grid is rendered twice? Make sure the original is disposed if this happens.

Add page size config option (default to 25).

Footer template

Empty table template

Allow the http module to be configured to use JSON or application/x-www-form-urlencoded.

