<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ output extension=".js" #>
/***************\
    templates
\***************/
gp.templates = gp.templates || {};
<#

/*
I started out using handlebars for basic templating. But I decided 
that with some minor modifications to the templates I could easily 
create a simple compiler and remove the dependency on handlebars.
*/

string path = "";

if (Directory.Exists(@"C:\Users\kitntodd"))
{
    path = @"C:\Users\kitntodd\OneDrive\Documents\Code\Projects\gridponent\src\views";
}
else if (Directory.Exists(@"C:\Users\tpiltingsrud"))
{
    path = @"C:\Users\tpiltingsrud\OneDrive\Documents\Code\Projects\gridponent\src\views";
}
else
{
    path = @"C:\Users\todd\OneDrive\Documents\Code\Projects\gridponent\src\views";
}

var files = new DirectoryInfo(path).GetFiles("*.html", SearchOption.TopDirectoryOnly);
foreach (var file in files)
{
    var lines = File.ReadAllLines(file.FullName);
#>
gp.templates['<#= file.Name.Replace(file.Extension, "") #>'] = function(model, arg) {
    var out = [];
<#
try
{
    foreach (var line in lines)
    {
        var tokens = Tokenize(line);

        foreach (var token in tokens) 
        {
#>    <#= ProcessToken(token) #><#
        }
    }
}
catch (Exception ex)
{
#>
    <#= ex.ToString() #>
<#
}
#>
    return out.join('');
};
<#
}
#>
<#+
private string Indent(int count)
{
	return new string(' ', count * 4);
}
private string[] Tokenize(string line)
{
    var regex = new System.Text.RegularExpressions.Regex("{{.+?}}");

    var matches = regex.Matches(line);

    if (matches.Count == 0) return new string[] { line.Trim() };

    var split = regex.Split(line);

    var tokens = new List<string>();

    int index = 0;

    bool matchesFirst = matches[0].Index == 0;

    foreach (Match m in matches)
    {
        if (matchesFirst)
        {
            tokens.Add(m.Value);
        }

        tokens.Add(split[index++]);

        if (!matchesFirst)
        {
            tokens.Add(m.Value);
        }
    }

    if (index < split.Length)
    {
        tokens.Add(split[index]);
    }

    return tokens.ToArray();
}
private string ProcessToken(string token)
{
    if (token == null) return "";
    if (token.Trim() == "") return token;

    if (token.StartsWith("{{#if"))
		return IfStatement(token);
    if (token == "{{else}}") 
		return "} else {\r\n";
    if (token == "{{/if}}") 
		return "}\r\n";

    if (token.StartsWith("{{#each")) return ForEachStatement(token);
    if (token == "{{/each}}") return "});\r\n";
    if (token == "{{@index}}") return "out.push(index);\r\n";

    if (token.StartsWith("{{template ")) return TemplateCall(token);
    if (token.StartsWith("{{helper ")) return HelperCall(token);
	if (token.StartsWith("{{")) return "out.push(" + Slice(token, 2, -2) + ");\r\n";

    return "out.push('" + token + "');\r\n";
}

private string IfStatement(string token)
{
    var arg = token.Substring(6, token.Length - 8);
    var sb = new StringBuilder();
    sb.Append("if (");
    sb.Append(arg);
    sb.Append(") {\r\n");
    return sb.ToString();
}

private string ForEachStatement(string token)
{
    var split = token.Replace("{{", "").Replace("}}", "").Split(' ');
    var length = "{{#each ".Length;
    var array = split[1];
	var arg = "item";
	split = token.Split('|');
	if (split.Length > 1) {
		arg = split[1];
	}

    var sb = new StringBuilder();
    sb.Append(array);
    sb.Append(".forEach(function(");
    sb.Append(arg);
    sb.Append(", index) {\r\n");
    return sb.ToString();
}

private string TemplateCall(string token)
{
    var split = token.Substring(2, token.Length - 4).Split(' ');
	var templateName = split[1].Replace("\"", "");
	var args = "";
	if (split.Length > 2) {
		args = ", " + String.Join(", ", split.Skip(2).ToArray());
	}

    return "out.push(gp.templates['" + templateName + "'](model" + args + "));\r\n";
}

private string HelperCall(string token)
{
    var split = token.Substring(2, token.Length - 4).Split(' ');
	var helperName = split[1].Replace("\"", "");
	var args = "";
	if (split.Length > 2) {
		args = ", " + String.Join(", ", split.Skip(2).ToArray());
	}

    return "out.push(gp.helpers['" + helperName + "'].call(model" + args + "));\r\n";
}

public string Slice(string source, int start, int end)
{
	if (string.IsNullOrEmpty(source)) {
		return source;
	}
	if (end < 0) // Keep this for negative end support
	{
		end = source.Length + end;
	}
	int len = end - start;               // Calculate length
	return source.Substring(start, len); // Return Substring of length
}


#>